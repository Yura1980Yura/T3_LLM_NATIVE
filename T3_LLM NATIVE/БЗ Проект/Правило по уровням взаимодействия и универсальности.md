## 🚨 КРИТИЧЕСКОЕ ПРАВИЛО: УРОВНИ ВЗАИМОДЕЙСТВИЯ И УНИВЕРСАЛЬНОСТЬ

### 📋 Формулировка 1: Дополнение к инструкциям проекта

```markdown
## 🎯 ДОПОЛНЕНИЕ К ИНСТРУКЦИЯМ: УРОВНИ РАБОТЫ С ФРЕЙМВОРКОМ

### При разработке и принятии решений ВСЕГДА учитывать три уровня:

1. **🏗️ УРОВЕНЬ ФРЕЙМВОРКА (МЫ)**
   - Мы создаем ФРЕЙМВОРК LLM NATIVE
   - Это базовая архитектура для создания систем
   - Должна быть максимально гибкой и расширяемой

2. **👨‍💻 УРОВЕНЬ РАЗРАБОТЧИКА**
   - Разработчик создает ПРОЕКТ на базе нашего фреймворка
   - Использует модули, сценарии, команды из LLM NATIVE
   - Адаптирует под свои задачи

3. **👤 УРОВЕНЬ КОНЕЧНОГО ПОЛЬЗОВАТЕЛЯ**
   - Пользователь использует готовый проект разработчика
   - Не знает о существовании фреймворка
   - Взаимодействует через интерфейс проекта

### 🌐 ТРЕБОВАНИЕ УНИВЕРСАЛЬНОСТИ:
Все проекты на базе фреймворка ДОЛЖНЫ универсально работать через:
- ✅ API запросы
- ✅ Custom GPT / Claude Projects
- ✅ Langchain и другие фреймворки
- ✅ Программы автоматизации (n8n, Make, Zapier)
- ✅ Обычный запрос в чат
- ✅ Любые другие способы интеграции

**⚠️ При принятии архитектурных решений ВСЕГДА проверять совместимость со всеми способами интеграции!**
```

### 📋 Формулировка 2: Критическое правило для документации LLM NATIVE

```markdown
## 🚨 КРИТИЧЕСКОЕ ПРАВИЛО АРХИТЕКТУРЫ LLM NATIVE

### ОБЯЗАТЕЛЬНОЕ ТРЕБОВАНИЕ: ТРЕХУРОВНЕВАЯ МОДЕЛЬ И УНИВЕРСАЛЬНОСТЬ

#### 🔴 ЖЕЛЕЗНОЕ ПРАВИЛО ТРЕХ УРОВНЕЙ:

```
┌─────────────────────────────────────────┐
│  1. ФРЕЙМВОРК (LLM NATIVE)             │
│     └─→ Мы разрабатываем базу          │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  2. ПРОЕКТ РАЗРАБОТЧИКА                │
│     └─→ Создается на базе фреймворка   │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  3. КОНЕЧНЫЙ ПОЛЬЗОВАТЕЛЬ              │
│     └─→ Использует готовый проект      │
└────────────────────────────────────────┘
```

#### 🔴 ЖЕЛЕЗНОЕ ПРАВИЛО УНИВЕРСАЛЬНОСТИ:

**КАЖДЫЙ компонент фреймворка ОБЯЗАН работать через ВСЕ каналы:**

| Канал интеграции | Обязательная поддержка |
|-----------------|------------------------|
| API запросы | ✅ ОБЯЗАТЕЛЬНО |
| Custom GPT | ✅ ОБЯЗАТЕЛЬНО |
| Claude Projects | ✅ ОБЯЗАТЕЛЬНО |
| Langchain | ✅ ОБЯЗАТЕЛЬНО |
| n8n / Make / Zapier | ✅ ОБЯЗАТЕЛЬНО |
| Прямой чат | ✅ ОБЯЗАТЕЛЬНО |

#### 🚫 ЗАПРЕЩЕНО:
- Создавать компоненты, работающие только в одном канале
- Использовать платформо-специфичные функции без fallback
- Нарушать универсальность ради удобства одной платформы

#### ✅ ОБЯЗАТЕЛЬНО:
- Тестировать каждый компонент на всех каналах
- Документировать особенности работы в разных каналах
- Предоставлять универсальные альтернативы

### 📌 ПРИМЕНЕНИЕ ПРАВИЛА:

При ЛЮБОМ архитектурном решении задавать вопросы:
1. Как это будет работать через API?
2. Как это будет работать в Custom GPT?
3. Как это будет работать в Claude Projects?
4. Как это будет работать в Langchain?
5. Как это будет работать в n8n?
6. Как это будет работать в обычном чате?

**Если хотя бы на один вопрос ответ "никак" или "сложно" - решение НЕПРИЕМЛЕМО!**

---

**🚨 ЭТО ПРАВИЛО ИМЕЕТ АБСОЛЮТНЫЙ ПРИОРИТЕТ НАД ЛЮБЫМИ ДРУГИМИ СООБРАЖЕНИЯМИ!**
```

## 🎓 НАСТАВНИЧЕСКИЕ ЗАМЕТКИ

💡 **Почему именно так:** Это правило критически важно для успеха фреймворка. Если мы создадим систему, которая работает только в одной среде, мы сильно ограничим возможности разработчиков и, как следствие, конечных пользователей.

📚 **Стоит изучить:** Принципы универсального дизайна API, паттерны платформо-независимой архитектуры, best practices интеграции с различными системами.

⚠️ **Важные моменты:** 
- Это правило должно применяться на КАЖДОМ этапе разработки
- При конфликте между "удобством" и "универсальностью" - выбираем универсальность
- Документация должна содержать примеры для ВСЕХ способов интеграции

## 📋 ПРИМЕНЕНИЕ В ПРОЕКТЕ

Это правило следует:
1. ✅ Добавить в раздел критических правил основной документации
2. ✅ Учитывать при review любых изменений архитектуры
3. ✅ Использовать как чек-лист при разработке новых компонентов
4. ✅ Включить в обучение новых участников проекта